{"version":3,"file":"local-sync.min.js","sources":["../../src/memoryStorage.js","../../src/LocalSync.js"],"sourcesContent":["let cache = {}\nlet length = 0\n\nconst memoryStorage = {\n  /**\n   * When passed a key name, will return that key's value.\n   * @param {String} key Name of the key you want to retrieve the value of.\n   * @returns {String|null}\n   */\n  getItem(key) {\n    return cache[key] || null\n  },\n\n  /**\n   * When passed a key name and value, will add that key to the storage,\n   * or update that key's value if it already exists.\n   * @param {String} key Name of the key you want to create/update.\n   * @param {String} value Value you want to give the key you are creating/updating.\n   * @returns {undefined}\n   */\n  setItem(key, value) {\n    if (typeof value === 'undefined') {\n      this.removeItem(key)\n    } else {\n      cache[key] = value.toString()\n      length++\n    }\n  },\n\n  /**\n   * When passed a key name, will remove that key from the storage.\n   * @param {String} key Name of the key you want to remove.\n   * @returns {undefined}\n   */\n  removeItem(key) {\n    if (!cache[key]) return\n\n    delete cache[key]\n    length--\n  },\n\n  /**\n   * When passed a number n, returns the name of the nth key in the storage.\n   * The order of keys is user-agent defined, so you should not rely on it.\n   * @param {Number} index A zero-based integer index representing the number of the key you want to get the name of.\n   * @returns {String|null}\n   */\n  key(index) {\n    return Object.keys(cache)[index] || null\n  },\n\n  /**\n   * When invoked, will empty all keys out of the storage.\n   * @returns {undefined}\n   */\n  clear() {\n    cache = {}\n    length = 0\n  },\n\n  /**\n   * The length read-only property returns an integer representing the number of data items stored.\n   * @readonly\n   * @returns {Number}\n   */\n  get length() {\n    return length\n  },\n}\n\nexport default memoryStorage\n","import memoryStorage from './memoryStorage.js'\n\n// --------------------------------------------------------\n// Utils\n// --------------------------------------------------------\n\nconst escapeRegExp = (str) => str.replace(/[|\\\\{}()[\\]^$+*?.]/g, '\\\\$&')\n\nconst storage = (function getStorageAdapter() {\n  // Default\n  let adapter = localStorage\n\n  // Feature detect and fallback to in-memory on fail. Ensures localStorage:\n  //  - exists\n  //  - can set/get/remove\n  //  - read/write values match\n  try {\n    const set = Date.now().toString(36)\n    adapter.setItem('uid', set)\n    if (adapter.getItem('uid') !== set) {\n      console.info(\n        'LocalSync: localStorage read/write is inconsistent, falling back to in-memory storage.'\n      )\n      adapter = memoryStorage\n    }\n    adapter.removeItem('uid')\n  } catch (err) {\n    console.error(err)\n    console.info('LocalSync: localStorage was not available, falling back to in-memory storage.')\n    adapter = memoryStorage\n  }\n\n  // create storage\n  return {\n    get: (key) => adapter.getItem(key),\n    set: (key, value) => adapter.setItem(key, value),\n    remove: (key) => adapter.removeItem(key),\n    key: (index) => adapter.key(index),\n    length: () => adapter.length,\n  }\n})()\n\n// --------------------------------------------------------\n// Local Sync\n// --------------------------------------------------------\n\nclass LocalSync {\n  /**\n   * Create a new Local Sync instance.  Each instance can have its own prefix, buckets, and separator.\n   * @param {Object} [options={}] Instance options.\n   * @param {String} [options.bucket=default] The bucket namespace to use.\n   * @param {String} [options.prefix=ls] The key prefix namespace to use.\n   * @param {String} [options.separator=.] Separates prefix, bucket, and keys.\n   * @constructor\n   */\n  constructor(options = {}) {\n    if (!(options instanceof Object)) throw new Error('LocalSync \"options\" must be an object.')\n\n    const bucket = this._validateBucket(options.bucket || 'default')\n    const prefix = this._validatePrefix(options.prefix || 'ls')\n    const separator = this._validateSeparator(options.separator || '.')\n\n    Object.defineProperties(this, {\n      _bucket: { value: bucket, writable: true, enumerable: false, configurable: false },\n      _prefix: { value: prefix, writable: true, enumerable: false, configurable: false },\n      _separator: { value: separator, writable: true, enumerable: false, configurable: false },\n    })\n  }\n\n  // --------------------------------------------------------\n  // Private API\n  // --------------------------------------------------------\n\n  /**\n   * Map over all `key`s in the current bucket.\n   * @param {Function} callback Called with each `key` string.\n   * @returns {Array} Array of callback return values.\n   * @private\n   */\n  _mapKeys(callback) {\n    const result = []\n    // iterate in reverse for max speed and index preservation when removing items\n    for (let i = storage.length() - 1; i >= 0; --i) {\n      const fullKey = storage.key(i)\n      if (fullKey.indexOf(this._fullBucket()) !== -1) {\n        result.unshift(callback(this._parseKey(fullKey)))\n      }\n    }\n    return result\n  }\n\n  /**\n   * Map over all buckets in storage.\n   * @param {Function} callback Called with each bucket string.\n   * @returns {Array} Array of callback return values.\n   * @private\n   */\n  _mapBuckets(callback) {\n    const result = []\n    // iterate in reverse for max speed and index preservation when removing items\n    for (let i = storage.length() - 1; i >= 0; --i) {\n      const fullKey = storage.key(i)\n      if (fullKey.indexOf(this._prefix) !== -1) {\n        result.unshift(callback(this._parseBucket(fullKey)))\n      }\n    }\n    return result\n  }\n\n  /**\n   * Get the full bucket name for the current bucket and `PREFIX`.\n   * @returns {String} Full bucket name.\n   * @private\n   */\n  _fullBucket() {\n    return [this._prefix, this._bucket].join(this._separator)\n  }\n\n  /**\n   * Get the full key name for the current bucket and `PREFIX`.\n   * @param {String} key The short `key` name to prefix.\n   * @returns {String} Full storage key name.\n   * @private\n   */\n  _fullKey(key) {\n    return [this._fullBucket(), key].join(this._separator)\n  }\n\n  /**\n   * Get the short bucket name, without the `PREFIX` nor any `key`.\n   * @param {String} fullKey The full key name including `PREFIX`, bucket, and `key`.\n   * @returns {String} The short `key` string.\n   * @private\n   */\n  _parseBucket(fullKey) {\n    const prefix = escapeRegExp(this._prefix)\n    const separator = escapeRegExp(this._separator)\n    const re = new RegExp(`${prefix}${separator}(.*)${separator}`)\n    const match = fullKey.match(re)\n    return (match && match[1]) || undefined\n  }\n\n  /**\n   * Get the short `key` name, without the current bucket nor `PREFIX`.\n   * @param {String} fullKey The full key name including `PREFIX`, bucket, and `key`.\n   * @returns {String} The short `key` string.\n   * @private\n   */\n  _parseKey(fullKey) {\n    const fullPrefix = this._fullKey('fakeKey').replace('fakeKey', '')\n    const prefixRegExp = new RegExp(escapeRegExp(fullPrefix))\n    return fullKey.replace(prefixRegExp, '')\n  }\n\n  /**\n   * Throw if `prefix` is not valid.\n   * @param {string} prefix The value to be validated.\n   * @returns {string} The validated `prefix`.\n   * @private\n   */\n  _validatePrefix(prefix) {\n    if (typeof prefix !== 'string') throw new Error('LocalSync \"prefix\" must be a string.')\n    if (prefix.indexOf(' ') !== -1) throw new Error('LocalSync \"prefix\" cannot contain spaces.')\n    if (prefix.indexOf(this._separator) !== -1) {\n      throw new Error(`LocalSync \"prefix\" cannot contain the separator \"${this._separator}\".`)\n    }\n    return prefix\n  }\n\n  /**\n   * Throw if `separator` is not valid.\n   * @param {string} separator The value to be validated.\n   * @returns {string} The validated `separator`.\n   * @private\n   */\n  _validateSeparator(separator) {\n    if (typeof separator !== 'string') throw new Error('LocalSync \"separator\" must be a string.')\n    if (separator.length !== 1) throw new Error('LocalSync \"separator\" must be a single character.')\n    return separator\n  }\n\n  /**\n   * Throw if `bucket` is not valid.\n   * @param {string} bucket The value to be validated.\n   * @returns {string} The validated `bucket`.\n   * @private\n   */\n  _validateBucket(bucket) {\n    if (typeof bucket !== 'string') throw new Error('LocalSync \"bucket\" must be a string.')\n    if (bucket.indexOf(' ') !== -1) throw new Error('LocalSync \"bucket\" cannot contain spaces.')\n    if (bucket.indexOf(this._separator) !== -1) {\n      throw new Error(`LocalSync \"bucket\" cannot contain the separator \"${this._separator}\".`)\n    }\n    return bucket\n  }\n\n  /**\n   * Throw if `key` is not valid.\n   * @param {string} key The value to be validated.\n   * @returns {string} The validated `key`.\n   * @private\n   */\n  _validateKey(key) {\n    if (typeof key !== 'string') throw new Error('LocalSync \"key\" parameter must be a string.')\n    if (key.indexOf(this._separator) !== -1) {\n      throw new Error(`LocalSync \"key\" cannot contain the separator \"${this._separator}\".`)\n    }\n    return key\n  }\n\n  /**\n   * Throw if `value` is not valid.\n   * @param {*} value The value to be validated.\n   * @returns {string} The validated `value`.\n   * @private\n   */\n  _validateValue(value) {\n    const validTypes = [null, undefined, true, 0, '', [], {}]\n    const signature = (arg) => Object.prototype.toString.call(arg)\n\n    if (!validTypes.some((valid) => signature(value) === signature(valid))) {\n      throw new Error(`LocalSync cannot store \"value\" of type ${signature(value)}`)\n    }\n    return value\n  }\n\n  // --------------------------------------------------------\n  // Public API\n  // --------------------------------------------------------\n\n  //\n  // Buckets\n  //\n\n  /**\n   * Set the current `bucket`. Methods will only operate on keys in this namespace.\n   * @param {String} bucket The bucket name.\n   * @returns {String} The bucket name just set.\n   */\n  setBucket(bucket) {\n    this._bucket = this._validateBucket(bucket)\n    return this._bucket\n  }\n\n  /**\n   * Get the current `bucket`.\n   * @returns {String} The current bucket name.\n   */\n  getBucket() {\n    return this._bucket\n  }\n\n  /**\n   * Get all buckets currently in storage.\n   * @returns {String[]} An array of bucket strings.\n   */\n  allBuckets() {\n    return this._mapBuckets((bucket) => bucket)\n  }\n\n  //\n  // Getters & Setters\n  //\n\n  /**\n   * Get a value from the current bucket.\n   * @param {String} key The name of the key you want to retrieve the value of.\n   * @returns {*} The stored value at the specified `key`.\n   */\n  get(key) {\n    this._validateKey(key)\n    const value = storage.get(this._fullKey(key))\n    try {\n      return value === 'undefined' ? undefined : JSON.parse(value)\n    } catch (e) {\n      console.error('Could not JSON.parse() value:', value)\n      throw e\n    }\n  }\n\n  /**\n   * Set a value in the current bucket.\n   * @param {String} key The name of the key you want to create/overwrite.\n   * @param {*} value The value for this key.\n   * @returns {*} The value that was just set.\n   */\n  set(key, value) {\n    this._validateKey(key)\n    this._validateValue(value)\n    storage.set(this._fullKey(key), JSON.stringify(value))\n    return this.get(key)\n  }\n\n  /**\n   * Update a value in the current bucket.\n   * @param {String} key The key under which the value to be updated is stored.\n   * @param {*} value Value to assign to the stored object.\n   * @returns {*} The updated value.\n   */\n  put(key, value) {\n    this._validateKey(key)\n    this._validateValue(value)\n    return this.set(key, Object.assign({}, this.get(key), value))\n  }\n\n  //\n  // Deleting\n  //\n\n  /**\n   * Remove a value from the current bucket.\n   * @param {String} key The key under which the value to be deleted is stored.\n   * @returns {*} The object just removed.\n   */\n  remove(key) {\n    this._validateKey(key)\n    const item = this.get(key)\n    storage.remove(this._fullKey(key))\n    return item\n  }\n\n  /**\n   * Clears all values from the current bucket.\n   */\n  clear() {\n    this.getAll().forEach((item) => {\n      this.remove(Object.keys(item)[0])\n    })\n  }\n\n  //\n  // Listing\n  //\n\n  /**\n   * Get all `key`s in the current bucket.\n   * @returns {String[]} An array of `key` strings.\n   */\n  keys() {\n    return this._mapKeys((key) => key)\n  }\n\n  /**\n   * Get all `value`s in the current bucket.\n   * @returns {Array.<*>} An array of values.\n   */\n  values() {\n    return this._mapKeys((key) => this.get(key))\n  }\n\n  /**\n   * Get all key/value pairs in the current bucket.\n   * @returns {Object[]} An array of objects `{<key>: <value>}`.\n   */\n  getAll() {\n    return this._mapKeys((key) => ({ [key]: this.get(key) }))\n  }\n}\n\nexport default LocalSync\n"],"names":["cache","length","memoryStorage","getItem","key","[object Object]","value","this","removeItem","toString","index","Object","keys","escapeRegExp","str","replace","storage","adapter","localStorage","set","Date","now","setItem","console","info","err","error","get","remove","options","Error","bucket","_validateBucket","prefix","_validatePrefix","separator","_validateSeparator","defineProperties","_bucket","writable","enumerable","configurable","_prefix","_separator","callback","result","i","fullKey","indexOf","_fullBucket","unshift","_parseKey","_parseBucket","join","re","RegExp","match","undefined","fullPrefix","_fullKey","prefixRegExp","signature","arg","prototype","call","some","valid","_mapBuckets","_validateKey","JSON","parse","e","_validateValue","stringify","assign","item","getAll","forEach","_mapKeys"],"mappings":"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"}