{"version":3,"file":"local-sync.min.js","sources":["../../src/memoryStorage.js","../../src/LocalSync.js"],"sourcesContent":["let cache = {}\nlet length = 0\n\nconst memoryStorage = {\n  /**\n   * When passed a key name, will return that key's value.\n   * @param {String} key Name of the key you want to retrieve the value of.\n   * @returns {String|null}\n   */\n  getItem(key) {\n    return cache[key] || null\n  },\n\n  /**\n   * When passed a key name and value, will add that key to the storage,\n   * or update that key's value if it already exists.\n   * @param {String} key Name of the key you want to create/update.\n   * @param {String} value Value you want to give the key you are creating/updating.\n   * @returns {undefined}\n   */\n  setItem(key, value) {\n    if (typeof value === 'undefined') {\n      this.removeItem(key)\n    } else {\n      cache[key] = value.toString()\n      length++\n    }\n  },\n\n  /**\n   * When passed a key name, will remove that key from the storage.\n   * @param {String} key Name of the key you want to remove.\n   * @returns {undefined}\n   */\n  removeItem(key) {\n    if (!cache[key]) return\n\n    delete cache[key]\n    length--\n  },\n\n  /**\n   * When passed a number n, returns the name of the nth key in the storage.\n   * The order of keys is user-agent defined, so you should not rely on it.\n   * @param {Number} index A zero-based integer index representing the number of the key you want to get the name of.\n   * @returns {String|null}\n   */\n  key(index) {\n    return Object.keys(cache)[index] || null\n  },\n\n  /**\n   * When invoked, will empty all keys out of the storage.\n   * @returns {undefined}\n   */\n  clear() {\n    cache = {}\n    length = 0\n  },\n\n  /**\n   * The length read-only property returns an integer representing the number of data items stored.\n   * @readonly\n   * @returns {Number}\n   */\n  get length() {\n    return length\n  },\n}\n\nexport default memoryStorage\n","import memoryStorage from './memoryStorage.js'\n\n// --------------------------------------------------------\n// Utils\n// --------------------------------------------------------\n\nconst escapeRegExp = (str) => str.replace(/[|\\\\{}()[\\]^$+*?.]/g, '\\\\$&')\n\nconst storage = (function getStorageAdapter() {\n  // Default\n  let adapter = localStorage\n\n  // Feature detect and fallback to in-memory on fail. Ensures localStorage:\n  //  - exists\n  //  - can set/get/remove\n  //  - read/write values match\n  try {\n    const set = Date.now().toString(36)\n    adapter.setItem('uid', set)\n    if (adapter.getItem('uid') !== set) {\n      console.info(\n        'LocalSync: localStorage read/write is inconsistent, falling back to in-memory storage.'\n      )\n      adapter = memoryStorage\n    }\n    adapter.removeItem('uid')\n  } catch (err) {\n    console.error(err)\n    console.info('LocalSync: localStorage was not available, falling back to in-memory storage.')\n    adapter = memoryStorage\n  }\n\n  // create storage\n  return {\n    get: (key) => adapter.getItem(key),\n    set: (key, value) => adapter.setItem(key, value),\n    remove: (key) => adapter.removeItem(key),\n    key: (index) => adapter.key(index),\n    length: () => adapter.length,\n  }\n})()\n\n// --------------------------------------------------------\n// Local Sync\n// --------------------------------------------------------\n\nclass LocalSync {\n  /**\n   * Create a new Local Sync instance.  Each instance can have its own prefix, buckets, and separator.\n   * @param {Object} [options={}] Instance options.\n   * @param {String} [options.bucket=default] The bucket namespace to use.\n   * @param {String} [options.prefix=ls] The key prefix namespace to use.\n   * @param {String} [options.separator=.] Separates prefix, bucket, and keys.\n   * @constructor\n   */\n  constructor(options = {}) {\n    if (!(options instanceof Object)) throw new Error('LocalSync \"options\" must be an object.')\n\n    const bucket = this._validateBucket(options.bucket || 'default')\n    const prefix = this._validatePrefix(options.prefix || 'ls')\n    const separator = this._validateSeparator(options.separator || '.')\n\n    Object.defineProperties(this, {\n      _bucket: { value: bucket, writable: true, enumerable: false, configurable: false },\n      _prefix: { value: prefix, writable: true, enumerable: false, configurable: false },\n      _separator: { value: separator, writable: true, enumerable: false, configurable: false },\n    })\n  }\n\n  // --------------------------------------------------------\n  // Private API\n  // --------------------------------------------------------\n\n  /**\n   * Map over all `key`s in the current bucket.\n   * @param {Function} callback Called with each `key` string.\n   * @returns {Array} Array of callback return values.\n   * @private\n   */\n  _mapKeys(callback) {\n    const result = []\n    // iterate in reverse for max speed and index preservation when removing items\n    for (let i = storage.length() - 1; i >= 0; --i) {\n      const fullKey = storage.key(i)\n      if (fullKey.indexOf(this._fullBucket()) !== -1) {\n        result.unshift(callback(this._parseKey(fullKey)))\n      }\n    }\n    return result\n  }\n\n  /**\n   * Map over all buckets in storage.\n   * @param {Function} callback Called with each bucket string.\n   * @returns {Array} Array of callback return values.\n   * @private\n   */\n  _mapBuckets(callback) {\n    const result = []\n    // iterate in reverse for max speed and index preservation when removing items\n    for (let i = storage.length() - 1; i >= 0; --i) {\n      const fullKey = storage.key(i)\n      if (fullKey.indexOf(this._prefix) !== -1) {\n        result.unshift(callback(this._parseBucket(fullKey)))\n      }\n    }\n    return result\n  }\n\n  /**\n   * Get the full bucket name for the current bucket and `PREFIX`.\n   * @returns {String} Full bucket name.\n   * @private\n   */\n  _fullBucket() {\n    return [this._prefix, this._bucket].join(this._separator)\n  }\n\n  /**\n   * Get the full key name for the current bucket and `PREFIX`.\n   * @param {String} key The short `key` name to prefix.\n   * @returns {String} Full storage key name.\n   * @private\n   */\n  _fullKey(key) {\n    return [this._fullBucket(), key].join(this._separator)\n  }\n\n  /**\n   * Get the short bucket name, without the `PREFIX` nor any `key`.\n   * @param {String} fullKey The full key name including `PREFIX`, bucket, and `key`.\n   * @returns {String} The short `key` string.\n   * @private\n   */\n  _parseBucket(fullKey) {\n    const prefix = escapeRegExp(this._prefix)\n    const separator = escapeRegExp(this._separator)\n    const re = new RegExp(`${prefix}${separator}(.*)${separator}`)\n    const match = fullKey.match(re)\n    return (match && match[1]) || undefined\n  }\n\n  /**\n   * Get the short `key` name, without the current bucket nor `PREFIX`.\n   * @param {String} fullKey The full key name including `PREFIX`, bucket, and `key`.\n   * @returns {String} The short `key` string.\n   * @private\n   */\n  _parseKey(fullKey) {\n    const fullPrefix = this._fullKey('fakeKey').replace('fakeKey', '')\n    const prefixRegExp = new RegExp(escapeRegExp(fullPrefix))\n    return fullKey.replace(prefixRegExp, '')\n  }\n\n  /**\n   * Throw if `prefix` is not valid.\n   * @param {string} prefix The value to be validated.\n   * @returns {string} The validated `prefix`.\n   * @private\n   */\n  _validatePrefix(prefix) {\n    if (typeof prefix !== 'string') throw new Error('LocalSync \"prefix\" must be a string.')\n    if (prefix.indexOf(' ') !== -1) throw new Error('LocalSync \"prefix\" cannot contain spaces.')\n    if (prefix.indexOf(this._separator) !== -1) {\n      throw new Error(`LocalSync \"prefix\" cannot contain the separator \"${this._separator}\".`)\n    }\n    return prefix\n  }\n\n  /**\n   * Throw if `separator` is not valid.\n   * @param {string} separator The value to be validated.\n   * @returns {string} The validated `separator`.\n   * @private\n   */\n  _validateSeparator(separator) {\n    if (typeof separator !== 'string') throw new Error('LocalSync \"separator\" must be a string.')\n    if (separator.length !== 1) throw new Error('LocalSync \"separator\" must be a single character.')\n    return separator\n  }\n\n  /**\n   * Throw if `bucket` is not valid.\n   * @param {string} bucket The value to be validated.\n   * @returns {string} The validated `bucket`.\n   * @private\n   */\n  _validateBucket(bucket) {\n    if (typeof bucket !== 'string') throw new Error('LocalSync \"bucket\" must be a string.')\n    if (bucket.indexOf(' ') !== -1) throw new Error('LocalSync \"bucket\" cannot contain spaces.')\n    if (bucket.indexOf(this._separator) !== -1) {\n      throw new Error(`LocalSync \"bucket\" cannot contain the separator \"${this._separator}\".`)\n    }\n    return bucket\n  }\n\n  /**\n   * Throw if `key` is not valid.\n   * @param {string} key The value to be validated.\n   * @returns {string} The validated `key`.\n   * @private\n   */\n  _validateKey(key) {\n    if (typeof key !== 'string') throw new Error('LocalSync \"key\" parameter must be a string.')\n    if (key.indexOf(this._separator) !== -1) {\n      throw new Error(`LocalSync \"key\" cannot contain the separator \"${this._separator}\".`)\n    }\n    return key\n  }\n\n  /**\n   * Throw if `value` is not valid.\n   * @param {*} value The value to be validated.\n   * @returns {string} The validated `value`.\n   * @private\n   */\n  _validateValue(value) {\n    const validTypes = [null, undefined, true, 0, '', [], {}]\n    const signature = (arg) => Object.prototype.toString.call(arg)\n\n    if (!validTypes.some((valid) => signature(value) === signature(valid))) {\n      throw new Error(`LocalSync cannot store \"value\" of type ${signature(value)}`)\n    }\n    return value\n  }\n\n  // --------------------------------------------------------\n  // Public API\n  // --------------------------------------------------------\n\n  //\n  // Buckets\n  //\n\n  /**\n   * Set the current `bucket`. Methods will only operate on keys in this namespace.\n   * @param {String} bucket The bucket name.\n   * @returns {String} The bucket name just set.\n   */\n  setBucket(bucket) {\n    this._bucket = this._validateBucket(bucket)\n    return this._bucket\n  }\n\n  /**\n   * Get the current `bucket`.\n   * @returns {String} The current bucket name.\n   */\n  getBucket() {\n    return this._bucket\n  }\n\n  /**\n   * Get all buckets currently in storage.\n   * @returns {String[]} An array of bucket strings.\n   */\n  allBuckets() {\n    return this._mapBuckets((bucket) => bucket)\n  }\n\n  //\n  // Getters & Setters\n  //\n\n  /**\n   * Get a value from the current bucket.\n   * @param {String} key The name of the key you want to retrieve the value of.\n   * @returns {*} The stored value at the specified `key`.\n   */\n  get(key) {\n    this._validateKey(key)\n    const value = storage.get(this._fullKey(key))\n    try {\n      return value === 'undefined' ? undefined : JSON.parse(value)\n    } catch (e) {\n      console.error('Could not JSON.parse() value:', value)\n      throw e\n    }\n  }\n\n  /**\n   * Set a value in the current bucket.\n   * @param {String} key The name of the key you want to create/overwrite.\n   * @param {*} value The value for this key.\n   * @returns {*} The value that was just set.\n   */\n  set(key, value) {\n    this._validateKey(key)\n    this._validateValue(value)\n    storage.set(this._fullKey(key), JSON.stringify(value))\n    return this.get(key)\n  }\n\n  /**\n   * Update a value in the current bucket.\n   * @param {String} key The key under which the value to be updated is stored.\n   * @param {*} value Value to assign to the stored object.\n   * @returns {*} The updated value.\n   */\n  put(key, value) {\n    this._validateKey(key)\n    this._validateValue(value)\n    return this.set(key, Object.assign({}, this.get(key), value))\n  }\n\n  //\n  // Deleting\n  //\n\n  /**\n   * Remove a value from the current bucket.\n   * @param {String} key The key under which the value to be deleted is stored.\n   * @returns {*} The object just removed.\n   */\n  remove(key) {\n    this._validateKey(key)\n    const item = this.get(key)\n    storage.remove(this._fullKey(key))\n    return item\n  }\n\n  /**\n   * Clears all values from the current bucket.\n   */\n  clear() {\n    this.getAll().forEach((item) => {\n      this.remove(Object.keys(item)[0])\n    })\n  }\n\n  //\n  // Listing\n  //\n\n  /**\n   * Get all `key`s in the current bucket.\n   * @returns {String[]} An array of `key` strings.\n   */\n  keys() {\n    return this._mapKeys((key) => key)\n  }\n\n  /**\n   * Get all `value`s in the current bucket.\n   * @returns {Array.<*>} An array of values.\n   */\n  values() {\n    return this._mapKeys((key) => this.get(key))\n  }\n\n  /**\n   * Get all key/value pairs in the current bucket.\n   * @returns {Object[]} An array of objects `{<key>: <value>}`.\n   */\n  getAll() {\n    return this._mapKeys((key) => ({ [key]: this.get(key) }))\n  }\n}\n\nexport default LocalSync\n"],"names":["cache","length","memoryStorage","getItem","key","[object Object]","value","this","removeItem","toString","index","Object","keys","escapeRegExp","str","replace","storage","adapter","localStorage","set","Date","now","setItem","console","info","err","error","get","remove","LocalSync","options","Error","bucket","_validateBucket","prefix","_validatePrefix","separator","_validateSeparator","defineProperties","_bucket","writable","enumerable","configurable","_prefix","_separator","callback","result","i","fullKey","indexOf","_fullBucket","unshift","_parseKey","_parseBucket","join","re","RegExp","match","undefined","fullPrefix","_fullKey","prefixRegExp","signature","arg","prototype","call","some","valid","_mapBuckets","_validateKey","JSON","parse","e","_validateValue","stringify","assign","item","getAll","forEach","_mapKeys","module"],"mappings":"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"}